[4mstring_copying[24m(7)                                                                     Miscellaneous Information Manual                                                                    [4mstring_copying[24m(7)

[1mNAME[0m
       stpcpy, strcpy, strcat, stpecpy, strtcpy, strlcpy, strlcat, stpncpy, strncpy, strncat - copying strings and character sequences

[1mSYNOPSIS[0m
   [1mStrings[0m
       // Chain-copy a string.
       [1mchar *stpcpy(char *restrict [4m[22mdst[24m[1m, const char *restrict [4m[22msrc[24m[1m);[0m

       // Copy/catenate a string.
       [1mchar *strcpy(char *restrict [4m[22mdst[24m[1m, const char *restrict [4m[22msrc[24m[1m);[0m
       [1mchar *strcat(char *restrict [4m[22mdst[24m[1m, const char *restrict [4m[22msrc[24m[1m);[0m

       // Chain-copy a string with truncation.
       [1mchar *stpecpy(char *[4m[22mdst[24m[1m, char [4m[22mend[24m[1m[0], const char *restrict [4m[22msrc[24m[1m);[0m

       // Copy/catenate a string with truncation.
       [1mssize_t strtcpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                      [1msize_t [4m[22mdsize[24m[1m);[0m
       [1msize_t strlcpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                      [1msize_t [4m[22mdsize[24m[1m);[0m
       [1msize_t strlcat(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                      [1msize_t [4m[22mdsize[24m[1m);[0m

   [1mNull-padded character sequences[0m
       // Fill a fixed-size buffer with characters from a string
       // and pad with null bytes.
       [1mchar *strncpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                      [1msize_t [4m[22mdsize[24m[1m);[0m
       [1mchar *stpncpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                      [1msize_t [4m[22mdsize[24m[1m);[0m

       // Chain-copy a null-padded character sequence into a character sequence.
       [4mmempcpy(dst,[24m [4msrc,[24m [4mstrnlen(src,[24m [4mNITEMS(src)));[0m

       // Chain-copy a null-padded character sequence into a string.
       [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mstrnlen(src,[24m [4mNITEMS(src))),[24m [4m"");[0m

       // Catenate a null-padded character sequence into a string.
       [1mchar *strncat(char *restrict [4m[22mdst[24m[1m, const char [4m[22msrc[24m[1m[restrict .[4m[22mssize[24m[1m],[0m
                      [1msize_t [4m[22mssize[24m[1m);[0m

   [1mKnown-length character sequences[0m
       // Chain-copy a known-length character sequence.
       [1mvoid *mempcpy(void [4m[22mdst[24m[1m[restrict .[4m[22mlen[24m[1m], const void [4m[22msrc[24m[1m[restrict .[4m[22mlen[24m[1m],[0m
                      [1msize_t [4m[22mlen[24m[1m);[0m

       // Chain-copy a known-length character sequence into a string.
       [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mlen),[24m [4m"");[0m

[1mDESCRIPTION[0m
   [1mTerms (and abbreviations)[0m
       [4mstring[24m ([4mstr[24m)
              is a sequence of zero or more non-null characters followed by a null character.

       [4mcharacter[24m [4msequence[0m
              is  a sequence of zero or more non-null characters.  A program should never use a character sequence where a string is required.  However, with appropriate care, a string can be used in the
              place of a character sequence.

              [4mnull-padded[24m [4mcharacter[24m [4msequence[0m
                     Character sequences can be contained in fixed-size buffers, which contain padding null bytes after the character sequence, to fill the rest of the buffer without affecting the  charâ€
                     acter  sequence;  however,  those padding null bytes are not part of the character sequence.  Don't confuse null-padded with null-terminated: null-padded means 0 or more padding null
                     bytes, while null-terminated means exactly 1 terminating null character.

              [4mknown-length[24m [4mcharacter[24m [4msequence[0m
                     Character sequence delimited by its length.  It may be a slice of a larger character sequence, or even of a string.

       [4mlength[24m ([4mlen[24m)
              is the number of non-null characters in a string or character sequence.  It is the return value of [4mstrlen(str)[24m and of [4mstrnlen(buf,[24m [4msize)[24m.

       [4msize[24m   refers to the entire buffer where the string or character sequence is contained.

       [4mend[24m    is the name of a pointer to one past the last element of a buffer.  It is equivalent to [4m&str[size][24m.  It is used as a sentinel value, to be able to truncate strings  or  character  sequences
              instead of overrunning the containing buffer.

       [4mcopy[24m   This term is used when the writing starts at the first element pointed to by [4mdst[24m.

       [4mcatenate[0m
              This term is used when a function first finds the terminating null character in [4mdst[24m, and then starts writing at that position.

       [4mchain[24m  This  term  is  used  when  it's the programmer who provides a pointer to the terminating null character in the string [4mdst[24m (or one after the last character in a character sequence), and the
              function starts writing at that location.  The function returns a pointer to the new location of the terminating null character (or one after the last character in a character sequence) afâ€
              ter the call, so that the programmer can use it to chain such calls.

   [1mCopy, catenate, and chain-copy[0m
       Originally, there was a distinction between functions that copy and those that catenate.  However, newer functions that copy while allowing chaining cover both use cases with a single  API.   They
       are also algorithmically faster, since they don't need to search for the terminating null character of the existing string.  However, functions that catenate have a much simpler use, so if perforâ€
       mance is not important, it can make sense to use them for improving readability.

       The  pointer  returned  by  functions that allow chaining is a byproduct of the copy operation, so it has no performance costs.  Functions that return such a pointer, and thus can be chained, have
       names of the form *[1mstp[22m*(), since it's common to name the pointer just [4mp[24m.

       Chain-copying functions that truncate should accept a pointer to the end of the destination buffer, and have names of the form *[1mstpe[22m*().  This allows not having to recalculate the  remaining  size
       after each call.

   [1mTruncate or not?[0m
       The first thing to note is that programmers should be careful with buffers, so they always have the correct size, and truncation is not necessary.

       In  most  cases,  truncation is not desired, and it is simpler to just do the copy.  Simpler code is safer code.  Programming against programming mistakes by adding more code just adds more points
       where mistakes can be made.

       Nowadays, compilers can detect most programmer errors with features like compiler warnings, static analyzers, and [1m_FORTIFY_SOURCE [22m(see [1mftm[22m(7)).  Keeping the code simple helps these overflow-detecâ€
       tion features be more precise.

       When validating user input, code should normally not truncate, but instead fail and prevent the copy at all.

       In some cases, however, it makes sense to truncate.

       Functions that truncate:

       â€¢  [1mstpecpy[22m()

       â€¢  [1mstrtcpy[22m()

       â€¢  [1mstrlcpy[22m(3bsd) and [1mstrlcat[22m(3bsd) are similar, but have important performance problems; see BUGS.

       â€¢  [1mstpncpy[22m(3) and [1mstrncpy[22m(3) also truncate, but they don't write strings, but rather null-padded character sequences.

   [1mNull-padded character sequences[0m
       For historic reasons, some standard APIs and file formats, such as [1mutmpx[22m(5) and [1mtar[22m(1), use null-padded character sequences in fixed-size buffers.  To interface with  them,  specialized  functions
       need to be used.

       To copy bytes from strings into these buffers, use [1mstrncpy[22m(3) or [1mstpncpy[22m(3).

       To read a null-padded character sequence, use [4mstrnlen(src,[24m [4mNITEMS(src))[24m, and then you can treat it as a known-length character sequence; or use [1mstrncat[22m(3) directly.

   [1mKnown-length character sequences[0m
       The  simplest  character  sequence  copying  function  is  [1mmempcpy[22m(3).  It requires always knowing the length of your character sequences, for which structures can be used.  It makes the code much
       faster, since you always know the length of your character sequences, and can do the minimal copies and length measurements.  [1mmempcpy[22m(3) copies character sequences, so you need to  explicitly  set
       the terminating null character if you need a string.

       In  programs that make considerable use of strings or character sequences, and need the best performance, using overlapping character sequences can make a big difference.  It allows holding subseâ€
       quences of a larger character sequence, while not duplicating memory nor using time to do a copy.

       However, this is delicate, since it requires using character sequences.  C library APIs use strings, so programs that use character sequences will have to take care of differentiating strings from
       character sequences.

       To copy a known-length character sequence, use [1mmempcpy[22m(3).

       To copy a known-length character sequence into a string, use [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mlen),[24m [4m"")[24m.

       A string is also accepted as input, because [1mmempcpy[22m(3) asks for the length, and a string is composed of a character sequence of the same length plus a terminating null character.

   [1mString vs character sequence[0m
       Some functions only operate on strings.  Those require that the input [4msrc[24m is a string, and guarantee an output string (even when truncation occurs).  Functions that catenate also require that  [4mdst[0m
       holds a string before the call.  List of functions:

       â€¢  [1mstpcpy[22m(3)
       â€¢  [1mstrcpy[22m(3), [1mstrcat[22m(3)
       â€¢  [1mstpecpy[22m()
       â€¢  [1mstrtcpy[22m()
       â€¢  [1mstrlcpy[22m(3bsd), [1mstrlcat[22m(3bsd)

       Other functions require an input string, but create a character sequence as output.  These functions have confusing names, and have a long history of misuse.  List of functions:

       â€¢  [1mstpncpy[22m(3)
       â€¢  [1mstrncpy[22m(3)

       Other  functions  operate  on  an input character sequence, and create an output string.  Functions that catenate also require that [4mdst[24m holds a string before the call.  [1mstrncat[22m(3) has an even more
       misleading name than the functions above.  List of functions:

       â€¢  [1mstrncat[22m(3)

       Other functions operate on an input character sequence to create an output character sequence.  List of functions:

       â€¢  [1mmempcpy[22m(3)

   [1mFunctions[0m
       [1mstpcpy[22m(3)
              Copy the input string into a destination string.  The programmer is responsible for allocating a buffer large enough.  It returns a pointer suitable for chaining.

       [1mstrcpy[22m(3)
       [1mstrcat[22m(3)
              Copy and catenate the input string into a destination string.  The programmer is responsible for allocating a buffer large enough.  The return value is useless.

              [1mstpcpy[22m(3) is a faster alternative to these functions.

       [1mstpecpy[22m()
              Chain-copy the input string into a destination string.  If the destination buffer, limited by a pointer to its end, isn't large enough to hold the copy, the resulting  string  is  truncated
              (but it is guaranteed to be null-terminated).  It returns a pointer suitable for chaining.  Truncation needs to be detected only once after the last chained call.

              This function is not provided by any library; see EXAMPLES for a reference implementation.

       [1mstrtcpy[22m()
              Copy  the  input  string into a destination string.  If the destination buffer isn't large enough to hold the copy, the resulting string is truncated (but it is guaranteed to be null-termiâ€
              nated).  It returns the length of the string, or -1 if it truncated.

              This function is not provided by any library; see EXAMPLES for a reference implementation.

       [1mstrlcpy[22m(3bsd)
       [1mstrlcat[22m(3bsd)
              Copy and catenate the input string into a destination string.  If the destination buffer, limited by its size, isn't large enough to hold the copy, the resulting string is truncated (but it
              is guaranteed to be null-terminated).  They return the length of the total string they tried to create.

              Check BUGS before using these functions.

              [1mstrtcpy[22m() and [1mstpecpy[22m() are better alternatives to these functions.

       [1mstpncpy[22m(3)
              Copy the input string into a destination null-padded character sequence in a fixed-size buffer.  If the destination buffer, limited by its size, isn't large enough to hold the copy, the reâ€
              sulting character sequence is truncated.  Since it creates a character sequence, it doesn't need to write a terminating null character.  It's impossible to distinguish truncation by the reâ€
              sult of the call, from a character sequence that just fits the destination buffer; truncation should be detected by comparing the length of the input string with the size of the destination
              buffer.

       [1mstrncpy[22m(3)
              This function is identical to [1mstpncpy[22m(3) except for the useless return value.

              [1mstpncpy[22m(3) is a more useful alternative to this function.

       [1mstrncat[22m(3)
              Catenate the input character sequence, contained in a null-padded fixed-size buffer, into a destination string.  The programmer is responsible for allocating a buffer large enough.  The reâ€
              turn value is useless.

              Do not confuse this function with [1mstrncpy[22m(3); they are not related at all.

              [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mstrnlen(src,[24m [4mNITEMS(src))),[24m [4m"")[24m is a faster alternative to this function.

       [1mmempcpy[22m(3)
              Copy the input character sequence, limited by its length, into a destination character sequence.  The programmer is responsible for allocating a buffer large enough.  It returns  a  pointer
              suitable for chaining.

[1mRETURN VALUE[0m
       [1mstpcpy[22m(3)
              A pointer to the terminating null character in the destination string.

       [1mstpecpy[22m()
              A pointer to the terminating null character in the destination string, on success.  On error, NULL is returned, and [4merrno[24m is set to indicate the error.

       [1mmempcpy[22m(3)
       [1mstpncpy[22m(3)
              A pointer to one after the last character in the destination character sequence.

       [1mstrtcpy[22m()
              The length of the string, on success.  On error, -1 is returned, and [4merrno[24m is set to indicate the error.

       [1mstrlcpy[22m(3bsd)
       [1mstrlcat[22m(3bsd)
              The length of the total string that they tried to create (as if truncation didn't occur).

       [1mstrcpy[22m(3)
       [1mstrcat[22m(3)
       [1mstrncpy[22m(3)
       [1mstrncat[22m(3)
              The [4mdst[24m pointer, which is useless.

[1mERRORS[0m
       Most of these functions don't set [4merrno[24m.

       [1mstpecpy[22m()
       [1mstrtcpy[22m()

              [1mENOBUFS[0m
                     [4mdsize[24m was [1m0[22m.

              [1mE2BIG  [22mThe string has been truncated.

[1mNOTES[0m
       The Linux kernel has an internal function for copying strings, [1mstrscpy[22m(9), which is identical to [1mstrtcpy[22m(), except that it returns [1m-E2BIG [22minstead of -1 and it doesn't set [4merrno[24m.

[1mCAVEATS[0m
       Don't  mix chain calls to truncating and non-truncating functions.  It is conceptually wrong unless you know that the first part of a copy will always fit.  Anyway, the performance difference will
       probably be negligible, so it will probably be more clear if you use consistent semantics: either truncating or non-truncating.  Calling a non-truncating function after a truncating one is  necesâ€
       sarily wrong.

[1mBUGS[0m
       All  catenation functions share the same performance problem: ]8;;https://www.joelonsoftware.com/2001/12/11/back-to-basics/\Shlemiel the painter]8;;\.  As a mitigation, compilers are able to transform some calls to catenation functions into normal copy functions,
       since [4mstrlen(dst)[24m is usually a byproduct of the previous copy.

       [1mstrlcpy[22m(3) and [1mstrlcat[22m(3) need to read the entire [4msrc[24m string, even if the destination buffer is small.  This makes them vulnerable to Denial of Service (DoS) attacks if an attacker can control the
       length of the [4msrc[24m string.  And if not, they're still unnecessarily slow.

[1mEXAMPLES[0m
       The following are examples of correct use of each of these functions.

       [1mstpcpy[22m(3)
              p = buf;
              p = stpcpy(p, "Hello ");
              p = stpcpy(p, "world");
              p = stpcpy(p, "!");
              len = p - buf;
              puts(buf);

       [1mstrcpy[22m(3)
       [1mstrcat[22m(3)
              strcpy(buf, "Hello ");
              strcat(buf, "world");
              strcat(buf, "!");
              len = strlen(buf);
              puts(buf);

       [1mstpecpy[22m()
              end = buf + NITEMS(buf);
              p = buf;
              p = stpecpy(p, end, "Hello ");
              p = stpecpy(p, end, "world");
              p = stpecpy(p, end, "!");
              if (p == NULL) {
                  len = NITEMS(buf) - 1;
                  goto toolong;
              }
              len = p - buf;
              puts(buf);

       [1mstrtcpy[22m()
              len = strtcpy(buf, "Hello world!", NITEMS(buf));
              if (len == -1)
                  goto toolong;
              puts(buf);

       [1mstrlcpy[22m(3bsd)
       [1mstrlcat[22m(3bsd)
              if (strlcpy(buf, "Hello ", NITEMS(buf)) >= NITEMS(buf))
                  goto toolong;
              if (strlcat(buf, "world", NITEMS(buf)) >= NITEMS(buf))
                  goto toolong;
              len = strlcat(buf, "!", NITEMS(buf));
              if (len >= NITEMS(buf))
                  goto toolong;
              puts(buf);

       [1mstpncpy[22m(3)
              p = stpncpy(u->ut_user, "alx", NITEMS(u->ut_user));
              if (NITEMS(u->ut_user) < strlen("alx"))
                  goto toolong;
              len = p - u->ut_user;
              fwrite(u->ut_user, 1, len, stdout);

       [1mstrncpy[22m(3)
              strncpy(u->ut_user, "alx", NITEMS(u->ut_user));
              if (NITEMS(u->ut_user) < strlen("alx"))
                  goto toolong;
              len = strnlen(u->ut_user, NITEMS(u->ut_user));
              fwrite(u->ut_user, 1, len, stdout);

       [4mmempcpy(dst,[24m [4msrc,[24m [4mstrnlen(src,[24m [4mNITEMS(src)))[0m
              char  buf[NITEMS(u->ut_user)];
              p = buf;
              p = mempcpy(p, u->ut_user, strnlen(u->ut_user, NITEMS(u->ut_user)));
              len = p - buf;
              fwrite(buf, 1, len, stdout);

       [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mstrnlen(src,[24m [4mNITEMS(src))),[24m [4m"")[0m
              char  buf[NITEMS(u->ut_user) + 1];
              p = buf;
              p = mempcpy(p, u->ut_user, strnlen(u->ut_user, NITEMS(u->ut_user)));
              p = stpcpy(p, "");
              len = p - buf;
              puts(buf);

       [1mstrncat[22m(3)
              char  buf[NITEMS(u->ut_user) + 1];
              strcpy(buf, "");
              strncat(buf, u->ut_user, NITEMS(u->ut_user));
              len = strlen(buf);
              puts(buf);

       [1mmempcpy[22m(3)
              p = buf;
              p = mempcpy(p, "Hello ", 6);
              p = mempcpy(p, "world", 5);
              p = mempcpy(p, "!", 1);
              len = p - buf;
              fwrite(buf, 1, len, stdout);

       [4mstpcpy(mempcpy(dst,[24m [4msrc,[24m [4mlen),[24m [4m"")[0m
              p = buf;
              p = mempcpy(p, "Hello ", 6);
              p = mempcpy(p, "world", 5);
              p = mempcpy(p, "!", 1);
              p = stpcpy(p, "");
              len = p - buf;
              puts(buf);

   [1mImplementations[0m
       Here are reference implementations for functions not provided by libc.

           /* This code is in the public domain. */

           char *
           [4mstpecpy[24m(char *dst, char end[0], const char *restrict src)
           {
               size_t  dlen;

               if (dst == NULL)
                   return NULL;

               dlen = strtcpy(dst, src, end - dst);
               return (dlen == -1) ? NULL : dst + dlen;
           }

           ssize_t
           [4mstrtcpy[24m(char *restrict dst, const char *restrict src, size_t dsize)
           {
               bool    trunc;
               size_t  dlen, slen;

               if (dsize == 0) {
                   errno = ENOBUFS;
                   return -1;
               }

               slen = strnlen(src, dsize);
               trunc = (slen == dsize);
               dlen = slen - trunc;

               stpcpy(mempcpy(dst, src, dlen), "");
               if (trunc)
                   errno = E2BIG;
               return trunc ? -1 : slen;
           }

[1mSEE ALSO[0m
       [1mbzero[22m(3), [1mmemcpy[22m(3), [1mmemccpy[22m(3), [1mmempcpy[22m(3), [1mstpcpy[22m(3), [1mstrlcpy[22m(3bsd), [1mstrncat[22m(3), [1mstpncpy[22m(3), [1mstring[22m(3)

Linux man-pages 6.7                                                                              2023-12-17                                                                               [4mstring_copying[24m(7)
