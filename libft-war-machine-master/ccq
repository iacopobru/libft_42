STRCMP(3)                                                                                 Linux Programmer's Manual                                                                                 STRCMP(3)

NNAAMMEE
       strcmp, strncmp - compare two strings

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssttrriinngg..hh>>

       iinntt ssttrrccmmpp((ccoonnsstt cchhaarr **_s_1,, ccoonnsstt cchhaarr **_s_2));;

       iinntt ssttrrnnccmmpp((ccoonnsstt cchhaarr **_s_1,, ccoonnsstt cchhaarr **_s_2,, ssiizzee__tt _n));;

DDEESSCCRRIIPPTTIIOONN
       The ssttrrccmmpp() function compares the two strings _s_1 and _s_2.  The locale is not taken into account (for a locale-aware comparison, see ssttrrccoollll(3)).  The comparison is done using unsigned characters.

       ssttrrccmmpp() returns an integer indicating the result of the comparison, as follows:

       • 0, if the _s_1 and _s_2 are equal;

       • a negative value if _s_1 is less than _s_2;

       • a positive value if _s_1 is greater than _s_2.

       The ssttrrnnccmmpp() function is similar, except it compares only the first (at most) _n bytes of _s_1 and _s_2.

RREETTUURRNN VVAALLUUEE
       The ssttrrccmmpp() and ssttrrnnccmmpp() functions return an integer less than, equal to, or greater than zero if _s_1 (or the first _n bytes thereof) is found, respectively, to be less than, to match, or be greater
       than _s_2.

AATTTTRRIIBBUUTTEESS
       For an explanation of the terms used in this section, see aattttrriibbuutteess(7).

       ┌────────────────────┬───────────────┬─────────┐
       │IInntteerrffaaccee           │ AAttttrriibbuuttee     │ VVaalluuee   │
       ├────────────────────┼───────────────┼─────────┤
       │ssttrrccmmpp(), ssttrrnnccmmpp() │ Thread safety │ MT-Safe │
       └────────────────────┴───────────────┴─────────┘
CCOONNFFOORRMMIINNGG TTOO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

NNOOTTEESS
       POSIX.1 specifies only that:

              The sign of a nonzero return value shall be determined by the sign of the difference between the values of the first pair of bytes (both interpreted as type _u_n_s_i_g_n_e_d _c_h_a_r) that differ in  the
              strings being compared.

       In  glibc,  as  in  most  other  implementations, the return value is the arithmetic result of subtracting the last compared byte in _s_2 from the last compared byte in _s_1.  (If the two characters are
       equal, this difference is 0.)

EEXXAAMMPPLLEESS
       The program below can be used to demonstrate the operation of ssttrrccmmpp() (when given two arguments) and ssttrrnnccmmpp() (when given three arguments).  First, some examples using ssttrrccmmpp():

           $ ..//ssttrriinngg__ccoommpp AABBCC AABBCC
           <str1> and <str2> are equal
           $ ..//ssttrriinngg__ccoommpp AABBCC AABB      # 'C' is ASCII 67; 'C' - ' ' = 67
           <str1> is greater than <str2> (67)
           $ ..//ssttrriinngg__ccoommpp AABBAA AABBZZ     # 'A' is ASCII 65; 'Z' is ASCII 90
           <str1> is less than <str2> (-25)
           $ ..//ssttrriinngg__ccoommpp AABBJJ AABBCC
           <str1> is greater than <str2> (7)
           $ .//ssttrriinngg__ccoommpp $$''\\220011'' AA   # 0201 - 0101 = 0100 (or 64 decimal)
           <str1> is greater than <str2> (64)

       The last example uses bbaasshh(1)-specific syntax to produce a string containing an 8-bit ASCII code; the result demonstrates that the string comparison uses unsigned characters.

       And then some examples using ssttrrnnccmmpp():

           $ ..//ssttrriinngg__ccoommpp AABBCC AABB 33
           <str1> is greater than <str2> (67)
           $ ..//ssttrriinngg__ccoommpp AABBCC AABB 22
           <str1> and <str2> are equal in the first 2 bytes

   PPrrooggrraamm ssoouurrccee

       /* string_comp.c

          Licensed under GNU General Public License v2 or later.
       */
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       int
       main(int argc, char *argv[])
       {
           int res;

           if (argc < 3) {
               fprintf(stderr, "Usage: %s <str1> <str2> [<len>]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (argc == 3)
               res = strcmp(argv[1], argv[2]);
           else
               res = strncmp(argv[1], argv[2], atoi(argv[3]));

           if (res == 0) {
               printf("<str1> and <str2> are equal");
               if (argc > 3)
                   printf(" in the first %d bytes\n", atoi(argv[3]));
               printf("\n");
           } else if (res < 0) {
               printf("<str1> is less than <str2> (%d)\n", res);
           } else {
               printf("<str1> is greater than <str2> (%d)\n", res);
           }

           exit(EXIT_SUCCESS);
       }

SSEEEE AALLSSOO
       bbccmmpp(3), mmeemmccmmpp(3), ssttrrccaasseeccmmpp(3), ssttrrccoollll(3), ssttrriinngg(3), ssttrrnnccaasseeccmmpp(3), ssttrrvveerrssccmmpp(3), wwccssccmmpp(3), wwccssnnccmmpp(3), aasscciiii(7)

CCOOLLOOPPHHOONN
       This page is part of release 5.10 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project,  information  about  reporting  bugs,  and  the  latest  version  of  this  page,  can  be  found  at
       https://www.kernel.org/doc/man-pages/.

                                                                                                  2020-04-11                                                                                        STRCMP(3)
